<?xml version="1.0" encoding="UTF-8"?>
<testplan name="apb_spec.pdf_verification" version="1.0">
    <metadata>
        <author>VEGA XTP Generator</author>
        <methodology>Cognitive Verification Architecture</methodology>
        <book>Cognitive Verification Architecture: The VEGA Framework by Vikash</book>
        <source>apb_spec.pdf</source>
    </metadata>
    
    <requirements>
        <requirement id="REQ_001" source="page 1-14">APB protocol is a low-cost interface optimized for minimal power consumption and reduced interface complexity</requirement>
        <requirement id="REQ_002" source="page 1-14">APB interface is not pipelined and is a simple, synchronous protocol</requirement>
        <requirement id="REQ_003" source="page 1-14">Every transfer takes at least two cycles to complete</requirement>
        <requirement id="REQ_004" source="page 2-17">PADDR can be up to 32 bits wide and indicates a byte address</requirement>
        <requirement id="REQ_005" source="page 2-17">PADDR is permitted to be unaligned with respect to data width but result is UNPREDICTABLE</requirement>
        <requirement id="REQ_006" source="page 2-18">APB protocol has two independent data buses - one for read data and one for write data</requirement>
        <requirement id="REQ_007" source="page 2-18">Data buses can be 8, 16, or 32 bits wide and must have the same width</requirement>
        <requirement id="REQ_008" source="page 2-18">Data transfers cannot occur concurrently because read and write data buses do not have individual handshake signals</requirement>
        <requirement id="REQ_009" source="page 3-20">Setup phase occurs at T1 where PSEL is asserted and PADDR, PWRITE, PWDATA must be valid</requirement>
        <requirement id="REQ_010" source="page 3-20">Access phase occurs at T2 where PENABLE is asserted</requirement>
        <requirement id="REQ_011" source="page 3-20">PADDR, PWDATA and control signals must be stable until transfer completes</requirement>
        <requirement id="REQ_012" source="page 3-21">PREADY can extend transfer by driving LOW during Access phase</requirement>
        <requirement id="REQ_013" source="page 3-21">PREADY can take any value when PENABLE is LOW</requirement>
        <requirement id="REQ_014" source="page 3-22">PSTRB enables sparse data transfer on write data bus with one strobe per 8 bits</requirement>
        <requirement id="REQ_015" source="page 3-22">PSTRB[n] corresponds to PWDATA[(8n + 7):(8n)]</requirement>
        <requirement id="REQ_016" source="page 3-22">PSTRB must be driven LOW during read transfers</requirement>
        <requirement id="REQ_017" source="page 3-25">PSLVERR indicates error condition on APB transfer for both read and write</requirement>
        <requirement id="REQ_018" source="page 3-25">PSLVERR is only valid during last cycle when PSEL, PENABLE, and PREADY are all HIGH</requirement>
        <requirement id="REQ_019" source="page 3-27">PPROT provides three levels of access protection: Normal/Privileged, Secure/Non-secure, Data/Instruction</requirement>
        <requirement id="REQ_020" source="page 3-28">PWAKEUP indicates activity associated with APB interface and must be glitch-free</requirement>
        <requirement id="REQ_021" source="page 3-29">User signals PAUSER, PWUSER, PRUSER, PBUSER provide user-defined attributes</requirement>
        <requirement id="REQ_022" source="page 4-32">APB operates through three states: IDLE, SETUP, ACCESS</requirement>
        <requirement id="REQ_023" source="page 4-32">Interface remains in SETUP state for exactly one clock cycle</requirement>
        <requirement id="REQ_024" source="page 4-32">Specific signals must not change between SETUP and ACCESS states</requirement>
        <requirement id="REQ_025" source="page 5-36">Parity check signals use odd parity with each bit covering maximum 8 payload bits</requirement>
        <requirement id="REQ_026" source="page 5-38">Check signals must be driven correctly when Check Enable term is True</requirement>
    </requirements>
    
    <test_suite name="basic_protocol_tests">
        <test_case id="TC_001" name="basic_write_no_wait_states">
            <objective>Verify basic write transfer with no wait states completes in exactly 2 cycles</objective>
            <source>Page 3-20, Figure 3-1</source>
            <preconditions>
                <condition>System in reset state</condition>
                <condition>PREADY tied HIGH</condition>
            </preconditions>
            <stimulus>
                <step order="1">Assert PRESETn to release reset</step>
                <step order="2">At T1: Assert PSEL, drive PADDR=0x1000, PWRITE=1, PWDATA=0xDEADBEEF</step>
                <step order="3">At T2: Assert PENABLE</step>
                <step order="4">At T3: Deassert PENABLE and PSEL</step>
            </stimulus>
            <expected_results>
                <result>Transfer completes at T3 rising edge</result>
                <result>PREADY sampled HIGH at T2</result>
                <result>Address and data stable from T1 to T3</result>
            </expected_results>
            <pass_criteria>Write transfer completes in exactly 2 cycles with correct timing</pass_criteria>
        </test_case>
        
        <test_case id="TC_002" name="basic_read_no_wait_states">
            <objective>Verify basic read transfer with no wait states</objective>
            <source>Page 3-23, Figure 3-4</source>
            <preconditions>
                <condition>System initialized</condition>
                <condition>PREADY tied HIGH</condition>
            </preconditions>
            <stimulus>
                <step order="1">At T1: Assert PSEL, drive PADDR=0x2000, PWRITE=0</step>
                <step order="2">At T2: Assert PENABLE</step>
                <step order="3">Completer drives PRDATA=0xCAFEBABE</step>
            </stimulus>
            <expected_results>
                <result>PRDATA valid before T3 rising edge</result>
                <result>Read data captured at T3</result>
                <result>Transfer completes in 2 cycles</result>
            </expected_results>
            <pass_criteria>Read data available and stable before transfer completion</pass_criteria>
        </test_case>
        
        <test_case id="TC_003" name="write_with_wait_states">
            <objective>Verify write transfer extension using PREADY</objective>
            <source>Page 3-21, Figure 3-2</source>
            <preconditions>
                <condition>System initialized</condition>
            </preconditions>
            <stimulus>
                <step order="1">At T1: Assert PSEL, drive PADDR, PWRITE=1, PWDATA</step>
                <step order="2">At T2: Assert PENABLE, drive PREADY=0</step>
                <step order="3">At T3: Keep PENABLE=1, PREADY=0</step>
                <step order="4">At T4: Drive PREADY=1</step>
            </stimulus>
            <expected_results>
                <result>Transfer extends while PREADY=0</result>
                <result>All control signals remain stable during wait states</result>
                <result>Transfer completes at T5 when PREADY=1</result>
            </expected_results>
            <pass_criteria>Transfer extends correctly and all signals stable during wait states</pass_criteria>
        </test_case>
        
        <test_case id="TC_004" name="state_machine_transitions">
            <objective>Verify correct state machine operation through IDLE-SETUP-ACCESS states</objective>
            <source>Page 4-32, Figure 4-1</source>
            <preconditions>
                <condition>System in IDLE state</condition>
            </preconditions>
            <stimulus>
                <step order="1">Initiate transfer by asserting PSEL (IDLE to SETUP)</step>
                <step order="2">Next cycle assert PENABLE (SETUP to ACCESS)</step>
                <step order="3">Wait for PREADY=1 to complete transfer</step>
                <step order="4">Return to IDLE or start new transfer</step>
            </stimulus>
            <expected_results>
                <result>State transitions occur as specified</result>
                <result>SETUP state lasts exactly one cycle</result>
                <result>ACCESS state controlled by PREADY</result>
            </expected_results>
            <pass_criteria>State machine follows specified transitions with correct timing</pass_criteria>
        </test_case>
    </test_suite>
    
    <test_suite name="address_data_bus_tests">
        <test_case id="TC_005" name="address_bus_width_32bit">
            <objective>Verify PADDR supports up to 32-bit addressing</objective>
            <source>Page 2-17</source>
            <preconditions>
                <condition>ADDR_WIDTH configured to 32</condition>
            </preconditions>
            <stimulus>
                <step order="1">Drive PADDR=0xFFFFFFFF during transfer</step>
                <step order="2">Drive PADDR=0x00000000 during next transfer</step>
                <step order="3">Drive PADDR=0x12345678 during third transfer</step>
            </stimulus>
            <expected_results>
                <result>All address values correctly transmitted</result>
                <result>No address bits truncated or corrupted</result>
            </expected_results>
            <pass_criteria>Full 32-bit address range supported</pass_criteria>
        </test_case>
        
        <test_case id="TC_006" name="unaligned_address_behavior">
            <objective>Verify behavior with unaligned addresses</objective>
            <source>Page 2-17</source>
            <preconditions>
                <condition>32-bit data bus width</condition>
            </preconditions>
            <stimulus>
                <step order="1">Perform write with PADDR=0x1001 (unaligned)</step>
                <step order="2">Perform write with PADDR=0x1002 (unaligned)</step>
                <step order="3">Perform write with PADDR=0x1003 (unaligned)</step>
            </stimulus>
            <expected_results>
                <result>Completer may use unaligned, aligned address, or signal error</result>
                <result>Behavior is UNPREDICTABLE but transfer should complete or error</result>
            </expected_results>
            <pass_criteria>Transfer completes or proper error signaling occurs</pass_criteria>
        </test_case>
        
        <test_case id="TC_007" name="data_bus_widths">
            <objective>Verify support for 8, 16, 32-bit data bus widths</objective>
            <source>Page 2-18</source>
            <preconditions>
                <condition>Configurable data width support</condition>
            </preconditions>
            <stimulus>
                <step order="1">Configure for 8-bit data bus, perform read/write</step>
                <step order="2">Configure for 16-bit data bus, perform read/write</step>
                <step order="3">Configure for 32-bit data bus, perform read/write</step>
            </stimulus>
            <expected_results>
                <result>All data widths function correctly</result>
                <result>Read and write data buses maintain same width</result>
                <result>Data integrity maintained at all widths</result>
            </expected_results>
            <pass_criteria>All supported data widths work correctly with proper data integrity</pass_criteria>
        </test_case>
    </test_suite>
    
    <test_suite name="write_strobe_tests">
        <test_case id="TC_008" name="byte_lane_write_strobes">
            <objective>Verify PSTRB controls individual byte lane updates</objective>
            <source>Page 3-22, Figure 3-3</source>
            <preconditions>
                <condition>32-bit data bus configured</condition>
            </preconditions>
            <stimulus>
                <step order="1">Write with PSTRB=4'b1000, PWDATA=0x12345678</step>
                <step order="2">Write with PSTRB=4'b0100, PWDATA=0xAABBCCDD</step>
                <step order="3">Write with PSTRB=4'b1010, PWDATA=0x11223344</step>
            </stimulus>
            <expected_results>
                <result>Only enabled byte lanes get updated</result>
                <result>PSTRB[3] affects PWDATA[31:24]</result>
                <result>PSTRB[2] affects PWDATA[23:16]</result>
                <result>PSTRB[1] affects PWDATA[15:8]</result>
                <result>PSTRB[0] affects PWDATA[7:0]</result>
            </expected_results>
            <pass_criteria>Only strobed byte lanes are updated, others remain unchanged</pass_criteria>
        </test_case>
        
        <test_case id="TC_009" name="strobe_read_restriction">
            <objective>Verify PSTRB is driven LOW during read transfers</objective>
            <source>Page 3-22</source>
            <preconditions>
                <condition>System initialized</condition>
            </preconditions>
            <stimulus>
                <step order="1">Perform read transfer with PWRITE=0</step>
                <step order="2">Monitor PSTRB during entire read transfer</step>
            </stimulus>
            <expected_results>
                <result>PSTRB driven to all zeros during read</result>
                <result>PSTRB remains LOW throughout read transfer</result>
            </expected_results>
            <pass_criteria>PSTRB is LOW for entire duration of read transfers</pass_criteria>
        </test_case>
    </test_suite>
    
    <test_suite name="error_handling_tests">
        <test_case id="TC_010" name="write_error_response">
            <objective>Verify error signaling for write transfers</objective>
            <source>Page 3-25, Figure 3-6</source>
            <preconditions>
                <condition>Completer supports PSLVERR</condition>
            </preconditions>
            <stimulus>
                <step order="1">Initiate write to invalid/protected address</step>
                <step order="2">Completer asserts PSLVERR during final cycle</step>
            </stimulus>
            <expected_results>
                <result>PSLVERR asserted only when PSEL, PENABLE, PREADY all HIGH</result>
                <result>Error condition properly indicated</result>
                <result>Transfer completes despite error</result>
            </expected_results>
            <pass_criteria>Error properly signaled with correct timing</pass_criteria>
        </test_case>
        
        <test_case id="TC_011" name="read_error_response">
            <objective>Verify error signaling for read transfers</objective>
            <source>Page 3-26, Figure 3-7</source>
            <preconditions>
                <condition>Completer supports PSLVERR</condition>
            </preconditions>
            <stimulus>
                <step order="1">Initiate read from invalid/protected address</step>
                <step order="2">Completer asserts PSLVERR during final cycle</step>
            </stimulus>
            <expected_results>
                <result>PSLVERR asserted with proper timing</result>
                <result>PRDATA may contain invalid data</result>
                <result>Transfer completes with error indication</result>
            </expected_results>
            <pass_criteria>Read error properly signaled, transfer completes</pass_criteria>
        </test_case>
        
        <test_case id="TC_012" name="error_without_pslverr">
            <objective>Verify operation when PSLVERR not supported</objective>
            <source>Page 3-25</source>
            <preconditions>
                <condition>PSLVERR tied LOW</condition>
            </preconditions>
            <stimulus>
                <step order="1">Perform various transfers including invalid addresses</step>
                <step order="2">Monitor for proper completion</step>
            </stimulus>
            <expected_results>
                <result>Transfers complete normally</result>
                <result>No error indication available</result>
                <result>System continues to operate</result>
            </expected_results>
            <pass_criteria>System operates correctly without error signaling capability</pass_criteria>
        </test_case>
    </test_suite>
    
    <test_suite name="protection_tests">
        <test_case id="TC_013" name="pprot_privilege_levels">
            <objective>Verify PPROT[0] indicates normal vs privileged access</objective>
            <source>Page 3-27, Table 3-2</source>
            <preconditions>
                <condition>System supports protection</condition>
            </preconditions>
            <stimulus>
                <step order="1">Transfer with PPROT[0]=0 (normal access)</step>
                <step order="2">Transfer with PPROT[0]=1 (privileged access)</step>
            </stimulus>
            <expected_results>
                <result>Protection attributes correctly transmitted</result>
                <result>Completer can use protection information</result>
            </expected_results>
            <pass_criteria>Protection levels correctly indicated and processed</pass_criteria>
        </test_case>
        
        <test_case id="TC_014" name="pprot_security_levels">
            <objective>Verify PPROT[1] indicates secure vs non-secure access</objective>
            <source>Page 3-27, Table 3-2</source>
            <preconditions>
                <condition>System supports security differentiation</condition>
            </preconditions>
            <stimulus>
                <step order="1">Transfer with PPROT[1]=0 (secure access)</step>
                <step order="2">Transfer with PPROT[1]=1 (non-secure access)</step>
            </stimulus>
            <expected_results>
                <result>Security attributes correctly transmitted</result>
                <result>Access control can be applied based on security level</result>
            </expected_results>
            <pass_criteria>Security levels correctly indicated and can be enforced</pass_criteria>
        </test_case>
        
        <test_case id="TC_015" name="pprot_access_type">
            <objective>Verify PPROT[2] indicates data vs instruction access</objective>
            <source>Page 3-27, Table 3-2</source>
            <preconditions>
                <condition>System differentiates access types</condition>
            </preconditions>
            <stimulus>
                <step order="1">Transfer with PPROT[2]=0 (data access)</step>
                <step order="2">Transfer with PPROT[2]=1 (instruction access)</step>
            </stimulus>
            <expected_results>
                <result>Access type hints correctly transmitted</result>
                <result>Hint information available to completer</result>
            </expected_results>
            <pass_criteria>Access type hints correctly provided as specified</pass_criteria>
        </test_case>
    </test_suite>
    
    <test_suite name="wakeup_signaling_tests">
        <test_case id="TC_016" name="wakeup_signal_timing">
            <objective>Verify PWAKEUP timing and glitch-free operation</objective>
            <source>Page 3-28</source>
            <preconditions>
                <condition>Wakeup_Signal property is True</condition>
            </preconditions>
            <stimulus>
                <step order="1">Assert PWAKEUP before PSEL assertion</step>
                <step order="2">Initiate APB transfer</step>
                <step order="3">Complete transfer</step>
                <step order="4">Deassert PWAKEUP when no more transfers</step>
            </stimulus>
            <expected_results>
                <result>PWAKEUP is glitch-free</result>
                <result>PWAKEUP asserted at least one cycle before PSEL</result>
                <result>PWAKEUP remains asserted until PREADY asserted</result>
            </expected_results>
            <pass_criteria>PWAKEUP provides proper wake-up signaling with correct timing</pass_criteria>
        </test_case>
    </test_suite>
    
    <test_suite name="user_signaling_tests">
        <test_case id="TC_017" name="user_request_attributes">
            <objective>Verify PAUSER signal behavior and timing</objective>
            <source>Page 3-29, Table 3-5</source>
            <preconditions>
                <condition>USER_REQ_WIDTH > 0</condition>
            </preconditions>
            <stimulus>
                <step order="1">Drive PAUSER with test pattern when PSEL asserted</step>
                <step order="2">Maintain PAUSER stable through Setup and Access phases</step>
            </stimulus>
            <expected_results>
                <result>PAUSER valid when PSELx asserted</result>
                <result>PAUSER same value in Setup and Access phases</result>
                <result>PAUSER stable during wait states</result>
            </expected_results>
            <pass_criteria>User request attributes correctly transmitted with proper timing</pass_criteria>
        </test_case>
        
        <test_case id="TC_018" name="user_write_data_attributes">
            <objective>Verify PWUSER signal behavior for write transfers</objective>
            <source>Page 3-29, Table 3-5</source>
            <preconditions>
                <condition>USER_DATA_WIDTH > 0</condition>
            </preconditions>
            <stimulus>
                <step order="1">Perform write transfer with PWUSER attributes</step>
                <step order="2">Verify PWUSER timing and stability</step>
            </stimulus>
            <expected_results>
                <result>PWUSER valid when PSEL and PWRITE asserted</result>
                <result>PWUSER stable throughout write transfer</result>
            </expected_results>
            <pass_criteria>User write data attributes correctly associated with write data</pass_criteria>
        </test_case>
        
        <test_case id="TC_019" name="user_read_response_attributes">
            <objective>Verify PRUSER and PBUSER signals for read transfers</objective>
            <source>Page 3-29, Table 3-5</source>
            <preconditions>
                <condition>USER_DATA_WIDTH > 0 and USER_RESP_WIDTH > 0</condition>
            </preconditions>
            <stimulus>
                <step order="1">Perform read transfer</step>
                <step order="2">Completer drives PRUSER and PBUSER during response</step>
            </stimulus>
            <expected_results>
                <result>PRUSER valid when PSEL, PENABLE, PREADY asserted and PWRITE deasserted</result>
                <result>PBUSER valid when PSEL, PENABLE, PREADY asserted</result>
            </expected_results>
            <pass_criteria>User response attributes correctly provided with proper timing</pass_criteria>
        </test_case>
    </test_suite>
    
    <test_suite name="parity_protection_tests">
        <test_case id="TC_020" name="address_parity_check">
            <objective>Verify PADDRCHK provides correct odd parity for address bus</objective>
            <source>Page 5-38, Table 5-1</source>
            <preconditions>
                <condition>Check_Type property is Odd_Parity_Byte_All</condition>
            </preconditions>
            <stimulus>
                <step order="1">Drive PADDR with known patterns</step>
                <step order="2">Generate PADDRCHK with odd parity per byte</step>
                <step order="3">Verify parity when PSEL asserted</step>
            </stimulus>
            <expected_results>
                <result>PADDRCHK provides odd parity for address groups</result>
                <result>Each parity bit covers maximum 8 address bits</result>
                <result>Parity valid when Check Enable (PSEL) is True</result>
            </expected_results>
            <pass_criteria>Address parity correctly generated and checked</pass_criteria>
        </test_case>
        
        <test_case id="TC_021" name="data_parity_check">
            <objective>Verify PWDATACHK and PRDATACHK provide correct data parity</objective>
            <source>Page 5-38, Table 5-1</source>
            <preconditions>
                <condition>Check_Type property is Odd_Parity_Byte_All</condition>
            </preconditions>
            <stimulus>
                <step order="1">Perform write with PWDATACHK parity generation</step>
                <step order="2">Perform read with PRDATACHK parity checking</step>
            </stimulus>
            <expected_results>
                <result>Write data parity valid when PSEL and PWRITE asserted</result>
                <result>Read data parity valid when PSEL, PENABLE, PREADY asserted and PWRITE deasserted</result>
                <result>Odd parity maintained for each byte lane</result>
            </expected_results>
            <pass_criteria>Data parity correctly generated and verified for both read and write</pass_criteria>
        </test_case>
        
        <test_case id="TC_022" name="control_signal_parity">
            <objective>Verify parity protection for critical control signals</objective>
            <source>Page 5-38, Table 5-1</source>
            <preconditions>
                <condition>Check_Type property is Odd_Parity_Byte_All</condition>
            </preconditions>
            <stimulus>
                <step order="1">Generate parity for PPROT, PWRITE (PCTRLCHK)</step>
                <step order="2">Generate parity for PENABLE (PENABLECHK)</step>
                <step order="3">Generate parity for PSELx (PSELxCHK)</step>
            </stimulus>
            <expected_results>
                <result>Control signal parity follows odd parity scheme</result>
                <result>Critical control signals have single parity bit protection</result>
                <result>Parity valid during appropriate check enable conditions</result>
            </expected_results>
            <pass_criteria>All control signals properly protected with parity</pass_criteria>
        </test_case>
    </test_suite>
    
    <test_suite name="signal_validity_tests">
        <test_case id="TC_023" name="always_valid_signals">
            <objective>Verify PSEL and PWAKEUP are always valid</objective>
            <source>Page A-40</source>
            <preconditions>
                <condition>System operational</condition>
            </preconditions>
            <stimulus>
                <step order="1">Monitor PSEL and PWAKEUP throughout operation</step>
                <step order="2">Verify signals driven to valid states</step>
            </stimulus>
            <expected_results>
                <result>PSEL never in undefined state</result>
                <result>PWAKEUP never in undefined state</result>
            </expected_results>
            <pass_criteria>Always-valid signals maintain defined states</pass_criteria>
        </test_case>
        
        <test_case id="TC_024" name="psel_dependent_validity">
            <objective>Verify signals valid when PSEL asserted</objective>
            <source>Page A-40</source>
            <preconditions>
                <condition>System ready for transfers</condition>
            </preconditions>
            <stimulus>
                <step order="1">Assert PSEL and verify dependent signals become valid</step>
                <step order="2">Check PADDR, PPROT, PENABLE, PWRITE, PAUSER, PSTRB</step>
            </stimulus>
            <expected_results>
                <result>All PSEL-dependent signals valid when PSEL asserted</result>
                <result>PWDATA and PWUSER valid for writes</result>
                <result>Signals maintain validity throughout transfer</result>
            </expected_results>
            <pass_criteria>Signal validity rules correctly followed</pass_criteria>
        </test_case>
        
        <test_case id="TC_025" name="response_signal_validity">
            <objective>Verify response signals valid at correct time</objective>
            <source>Page A-40</source>
            <preconditions>
                <condition>Transfer in progress</condition>
            </preconditions>
            <stimulus>
                <step order="1">Check PREADY valid when PSEL and PENABLE asserted</step>
                <step order="2">Check PRDATA, PSLVERR, PRUSER, PBUSER valid when all response conditions met</step>
            </stimulus>
            <expected_results>
                <result>PREADY valid during Access phase</result>
                <result>Response signals valid when PSEL, PENABLE, PREADY all asserted</result>
                <result>Read-specific signals only valid during reads</result>
            </expected_results>
            <pass_criteria>Response signal validity follows specification timing</pass_criteria>
        </test_case>
    </test_suite>
    
    <test_suite name="cross_feature_tests">
        <test_case id="TC_CF_001" name="write_strobe_with_protection">
            <objective>Test interaction between PSTRB and PPROT during sparse writes</objective>
            <features_involved>Write Strobes, Protection Unit Support</features_involved>
            <stimulus>
                <step order="1">Perform sparse write with specific PSTRB pattern</step>
                <step order="2">Include PPROT protection attributes</step>
                <step order="3">Verify both features work together</step>
            </stimulus>
            <expected_results>
                <result>Sparse write respects byte enables</result>
                <result>Protection attributes correctly applied</result>
                <result>No interference between features</result>
            </expected_results>
        </test_case>
    </test_suite>
</testplan>